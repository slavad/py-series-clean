#!/usr/bin/env python

import argparse
import py_series_clean.clean as pscc
import helpers.file_readers as fr
import helpers.argument_parsers as ap
import helpers.input_validators as iv
import helpers.constants as constants

ADDITIONAL_HELP = 'iterations stop if the number of maximum iterations is exceeded or the series do not contain signal at the given treshold'

def check_share(value):
    """checks value that should be 0<x<=1"""
    number = iv.check_positive_float(value)
    if number <= 0 or number > 1:
        raise argparse.ArgumentTypeError("value must be > 0 and <= 1, but your's is %s" % value)
    return number

def parse_args():
    descr = 'Reads and analyzes file with time series'
    parser = argparse.ArgumentParser(description=descr)
    ap.parse_common_series_args(parser)
    parser.add_argument(
        '-t',
        required = True,
        help = 'detection treshold (aka X_q), see eq 48 and 152 in ref 2, can be esitmated using estimate_treshold script {}'.format(ADDITIONAL_HELP),
        metavar ='TRESHOLD',
        type = check_share
    )
    parser.add_argument(
        '-r',
        required = True,
        help = 'maximum number of iteratoins: {}'.format(ADDITIONAL_HELP),
        metavar ='MAX_ITERATIONS',
        type = iv.check_positive_int
    )

    parser.add_argument(
        '-g',
        required = True,
        help = 'share of the harmonic in the dirty spectrum, eq 156 ref 2 ',
        metavar ='HARONIC_SHARE',
        type = check_share
    )
    parser.add_argument(
        '-c',
        required = True,
        help='correlogram output file location, {}'.format(constants.OUTPUT_FORMAT_INFO),
        metavar='CORRELOGRAM_FILE'
    )
    parser.add_argument(
        '-s',
        required = True,
        help='cleaned time series output file location, {}'.format(constants.OUTPUT_FORMAT_INFO),
        metavar='SERIES_FILE'
    )
    parser.add_argument(
        '-o',
        required = True,
        help='summary output file location',
        metavar='SUMMARY_FILE'
    )
    args = parser.parse_args()
    return args

def save_results(restoration_result, args):
    """saving restoration results"""
    #TODO: output warning if max_iterations == iterations
    khi = args.k
    treshold = args.t
    max_iterations = args.r
    harmonic_share = args.g
    input_file = args.i
    correlogram_file = args.c
    series_file = args.s
    summary_file = args.o

def main():
    """entry point"""
    args = parse_args()
    time_grid_and_values = fr.read_file(args.i)
    restoration_result = pscc.clean(time_grid_and_values, args.k, args.t, args.r, args.g)
    save_results(restoration_result, args)
main()